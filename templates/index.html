{% extends "base.html" %}
{% block content %}

<div class="mb-4 border-b border-slate-200">
  <nav class="-mb-px flex items-center justify-between" id="tabs">
    <div class="flex gap-6">
      <button data-tab="chat" class="py-2 border-b-2 border-sky-600 text-sky-700 font-medium">Чат</button>
      <button data-tab="doc"  class="py-2 border-b-2 border-transparent text-slate-500 hover:text-slate-700">Обробка постанови НБУ</button>
      <button data-tab="results" class="py-2 border-b-2 border-transparent text-slate-500 hover:text-slate-700">Результати</button>
      {% if logged_in %}
      <button data-tab="corpus" class="py-2 border-b-2 border-transparent text-slate-500 hover:text-slate-700">Документи</button>
      {% endif %}
    </div>
    <div class="text-sm">
      {% if logged_in %}
        <a href="{{ url_for('logout') }}" class="text-slate-600 hover:text-slate-800">Вийти</a>
      {% else %}
        <a href="{{ url_for('login') }}" class="text-slate-600 hover:text-slate-800">Увійти</a>
      {% endif %}
    </div>
  </nav>
</div>

<!-- Chat tab -->
<section id="tab-chat" class="flex-1 min-h-0 flex flex-col">
  <div class="flex-1 min-h-0 bg-white rounded-lg shadow p-4 flex flex-col">
    <div id="chat-log" class="flex-1 overflow-y-auto space-y-3 mb-4 pr-2 min-h-0">
      <!-- messages -->
    </div>
    <form id="chat-form" class="flex gap-2" autocomplete="off">
      <input id="chat-input" name="chat_input" class="flex-1 border border-slate-300 rounded px-3 py-2" placeholder="Введіть запитання..." autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false" />
      <button class="bg-sky-600 text-white px-4 py-2 rounded hover:bg-sky-700">
        <img src="{{ url_for('static', filename='images/icons/send.png') }}" alt="Send" class="w-5 h-5">
      </button>
    </form>
  </div>
</section>

<!-- Doc tab -->
<section id="tab-doc" class="hidden">
  <div class="bg-white rounded-lg shadow p-4 space-y-4">
    <form id="upload-form" class="space-y-3">
      <input id="file-input" type="file" accept=".docx" class="hidden" />

      <div id="dropzone" class="flex flex-col items-center justify-center w-full border-2 border-dashed border-slate-300 rounded-lg px-4 py-10 text-center cursor-pointer hover:border-slate-400 transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-8 h-8 text-slate-400 mb-2">
          <path fill-rule="evenodd" d="M3 3a2 2 0 012-2h10a2 2 0 012 2v7.586a2 2 0 01-.586 1.414l-4.414 4.414A2 2 0 0110.586 17H5a2 2 0 01-2-2V3zm8 0H9v6H6l4 4 4-4h-3V3z" clip-rule="evenodd" />
        </svg>
        <p class="text-sm text-slate-600"><span class="dz-label">Перетягніть .docx сюди або натисніть, щоб обрати</span></p>
        <p class="text-xs text-slate-400 mt-1">Підтримується лише один файл .docx</p>
      </div>

      <div class="flex items-center gap-3">
        <button id="upload-start" class="bg-sky-600 text-white px-4 py-2 rounded hover:bg-sky-700" type="submit">Розпочати</button>
        <button id="pick-file" type="button" class="border border-slate-300 text-slate-700 px-4 py-2 rounded hover:bg-slate-50">Оберіть .docx</button>
        <span id="chosen-file" class="text-sm text-slate-500"></span>
      </div>
    </form>

    <div id="uploading-banner" class="hidden rounded border border-amber-200 bg-amber-50 text-amber-800 px-3 py-2 text-sm">
      <span id="uploading-text">Завантаження та запуск обробки…</span>
    </div>

    <div id="progress" class="hidden">
      <div class="flex items-center justify-between">
        <div>
          <div id="file-name" class="text-sm text-slate-500"></div>
          <div class="text-sm" id="status-line"></div>
        </div>
        <a id="download-link" class="hidden bg-emerald-600 text-white px-3 py-2 rounded hover:bg-emerald-700" href="#">Завантажити DOCX</a>
      </div>
      <div class="mt-3 w-full bg-slate-200 rounded h-3">
        <div id="bar" class="bg-sky-600 h-3 rounded" style="width:0%"></div>
      </div>
      <div id="last-brief" class="text-xs text-slate-500 mt-2"></div>
    </div>

    <p class="text-xs text-slate-500">Обробка документу може зайняти тривалий проміжок часу. Прогрес оновлюється в реальному часі.</p>
  </div>
</section>

<!-- Results tab -->
<section id="tab-results" class="hidden">
  <div class="bg-white rounded-lg shadow p-4">
    <div class="flex items-center justify-between mb-3">
      <h3 class="font-medium">Опрацьовані файли</h3>
      <div class="flex items-center gap-3">
        <label class="text-sm text-slate-600 flex items-center gap-2">
          Елементів на сторінку
          <select id="results-page-size" class="border border-slate-300 rounded px-2 py-1 text-sm">
            <option value="25">25</option>
            <option value="50" selected>50</option>
            <option value="100">100</option>
          </select>
        </label>
        <div class="flex items-center gap-2">
          <button id="results-prev" class="border border-slate-300 text-slate-700 px-2 py-1 rounded hover:bg-slate-50">Попередня</button>
          <span id="results-page-info" class="text-sm text-slate-600">Page 1/1</span>
          <button id="results-next" class="border border-slate-300 text-slate-700 px-2 py-1 rounded hover:bg-slate-50">Наступна</button>
        </div>
        <button id="refresh-results" class="border border-slate-300 text-slate-700 px-3 py-1.5 rounded hover:bg-slate-50">Оновити</button>
      </div>
    </div>
    <div class="overflow-x-auto">
      <table class="min-w-full text-sm">
        <thead class="text-slate-500">
          <tr>
            <th class="text-left font-medium py-2 pr-4">Файл</th>
            <th class="text-left font-medium py-2 pr-4">Розмір</th>
            <th class="text-left font-medium py-2 pr-4">Дата</th>
            <th class="text-left font-medium py-2 pr-4">Дія</th>
          </tr>
        </thead>
        <tbody id="results-tbody" class="align-top"></tbody>
      </table>
    </div>
    <p class="text-xs text-slate-500 mt-3"></p>
  </div>
</section>

<!-- Corpus tab -->
<section id="tab-corpus" class="hidden">
  <div class="bg-white rounded-lg shadow p-4 space-y-4">
    {% if not logged_in %}
      <div class="text-slate-600">Потрібен вхід, щоб керувати документами. <a class="text-sky-600 hover:underline" href="{{ url_for('login') }}">Увійти</a></div>
    {% else %}
    <div id="controls-row" class="flex flex-col gap-4">
      <!-- Upload card -->
      <div id="upload-card" class="border border-slate-200 rounded-lg p-3 bg-white shadow-sm w-full">
        <div class="flex items-center justify-between cs-card-header">
          <div class="text-sm font-medium">Завантаження документа</div>
          <button id="toggle-upload" class="text-xs text-slate-600 border border-slate-300 px-2 py-1 rounded hover:bg-slate-50">Згорнути</button>
        </div>
        <div id="upload-body">
          <form id="corpus-upload-form" class="flex items-center gap-2 flex-wrap">
            <input id="corpus-rel-dir" type="hidden" />
            <span class="text-sm text-slate-600 min-w-0">Папка: <span id="corpus-selected" class="font-medium break-words">/</span></span>
            <input id="corpus-file" type="file" accept=".docx" class="hidden" />
            <button id="corpus-pick" type="button" class="border border-slate-300 text-slate-700 px-3 py-1.5 rounded hover:bg-slate-50">Оберіть .docx</button>
            <span id="corpus-chosen" class="text-sm text-slate-500 break-words max-w-full"></span>
            <button class="bg-sky-600 text-white px-3 py-1.5 rounded hover:bg-sky-700" type="submit">Завантажити</button>
          </form>
        </div>
      </div>

      <!-- Folder actions card -->
      <div id="folders-card" class="border border-slate-200 rounded-lg p-3 bg-white shadow-sm w-full">
        <div class="flex items-center justify-between cs-card-header">
          <div class="text-sm font-medium">Керування папками</div>
          <button id="toggle-folders" class="text-xs text-slate-600 border border-slate-300 px-2 py-1 rounded hover:bg-slate-50">Згорнути</button>
        </div>
        <div id="folders-body">
          <div class="flex items-center gap-2 flex-wrap">
            <button id="select-root" class="border border-slate-300 text-slate-700 px-3 py-1.5 rounded hover:bg-slate-50" title="Вибрати кореневу папку">Вибрати /</button>
            <input id="mkdir-name" type="text" placeholder="Нова папка" class="border border-slate-300 rounded px-2 py-1 text-sm min-w-[12rem]" />
            <button id="mkdir-btn" class="border border-slate-300 text-slate-700 px-3 py-1.5 rounded hover:bg-slate-50">Створити</button>
            <button id="rmdir-btn" class="border border-red-300 text-red-700 px-3 py-1.5 rounded hover:bg-red-50">Видалити</button>
            <button id="collapse-all" class="border border-slate-300 text-slate-700 px-3 py-1.5 rounded hover:bg-slate-50">Згорнути все</button>
          </div>
        </div>
      </div>

      <!-- Settings card -->
      <div id="settings-card" class="border border-slate-200 rounded-lg p-3 bg-white shadow-sm w-full">
        <div class="flex items-center justify-between cs-card-header">
          <div class="text-sm font-medium">Налаштування</div>
          <button id="toggle-settings" class="text-xs text-slate-600 border border-slate-300 px-2 py-1 rounded hover:bg-slate-50">Згорнути</button>
        </div>
        <div id="settings-body">
          <label class="text-sm text-slate-600 flex items-center gap-2">
            Показ джерела:
            <select id="source-label-mode" class="border border-slate-300 rounded px-2 py-1 text-sm">
              <option value="filename">Назва файлу</option>
              <option value="docx_relpath">Шлях (docx_relpath)</option>
            </select>
          </label>
        </div>
      </div>

      <!-- Vector store actions card -->
      <div id="vs-card" class="border border-slate-200 rounded-lg p-3 bg-white shadow-sm w-full">
        <div class="flex items-center justify-between cs-card-header">
          <div class="text-sm font-medium">Синхронізація векторного сховища</div>
          <button id="toggle-vs" class="text-xs text-slate-600 border border-slate-300 px-2 py-1 rounded hover:bg-slate-50">Згорнути</button>
        </div>
        <div id="vs-body">
          <div class="flex items-center gap-2 flex-wrap">
            <button id="sync-vs" class="border border-emerald-300 text-emerald-700 px-3 py-1.5 rounded hover:bg-emerald-50">Синхронізувати</button>
            <button id="verify-vs" class="border border-blue-300 text-blue-700 px-3 py-1.5 rounded hover:bg-blue-50">Перевірити</button>
            <button id="initdb-vs" class="border border-violet-300 text-violet-700 px-3 py-1.5 rounded hover:bg-violet-50">Init from DB</button>
            <button id="dryrun-vs" class="border border-amber-300 text-amber-700 px-3 py-1.5 rounded hover:bg-amber-50">Dry‑run</button>
            <button id="prune-vs" class="border border-rose-300 text-rose-700 px-3 py-1.5 rounded hover:bg-rose-50">Очистити зайве</button>
            <button id="corpus-refresh" class="border border-slate-300 text-slate-700 px-3 py-1.5 rounded hover:bg-slate-50">Оновити</button>
          </div>
          <div class="mt-4">
            <div class="text-sm text-slate-600 mb-1">Звіт синхронізації</div>
            <pre id="corpus-report" class="bg-slate-50 border border-slate-200 rounded p-3 text-xs overflow-x-auto overflow-y-auto max-h-72 break-words"></pre>
          </div>
        </div>
      </div>
    </div>

    <div id="corpus-tree" class="text-sm break-words mt-4 border border-slate-200 rounded-lg p-3 bg-white shadow-sm overflow-x-auto"></div>
    {% endif %}
  </div>
</section>


<script>
  // Tabs
  const tabs = document.querySelectorAll('#tabs button');
  const viewChat = document.getElementById('tab-chat');
  const viewDoc  = document.getElementById('tab-doc');
  const viewCorpus  = document.getElementById('tab-corpus');
  tabs.forEach(b => b.addEventListener('click', () => {
    tabs.forEach(x => { x.classList.remove('border-sky-600','text-sky-700'); x.classList.add('border-transparent','text-slate-500'); });
    b.classList.add('border-sky-600','text-sky-700'); b.classList.remove('text-slate-500');
    const tab = b.dataset.tab;
    viewChat.classList.add('hidden');
    viewDoc.classList.add('hidden');
    document.getElementById('tab-results').classList.add('hidden');
    viewCorpus.classList.add('hidden');
    if (tab === 'chat') document.getElementById('tab-chat').classList.remove('hidden');
    else if (tab === 'doc') document.getElementById('tab-doc').classList.remove('hidden');
    else if (tab === 'results') {
      document.getElementById('tab-results').classList.remove('hidden');
      loadResults(); // auto load when switching to results
    } else if (tab === 'corpus') {
      viewCorpus.classList.remove('hidden');
      loadCorpus();
    }
  }));

  // Chat
  const chatForm = document.getElementById('chat-form');
  const chatInput = document.getElementById('chat-input');
  const chatLog = document.getElementById('chat-log');

  // Clear any persisted value the browser may restore
  try { chatInput.value = ''; } catch (_) {}
  chatInput.addEventListener('focus', () => { if (chatInput.value && chatInput.value === chatInput.getAttribute('placeholder')) chatInput.value = ''; });

  function addMsg(who, text) {
    const wrap = document.createElement('div');
    wrap.className = who === 'you' ? 'flex justify-end' : 'flex justify-start';
    const b = document.createElement('div');
    b.className = who === 'you'
      ? 'bg-sky-600 text-white rounded px-3 py-2 max-w-[80%] whitespace-pre-wrap break-words'
      : 'bg-slate-100 text-slate-900 rounded px-3 py-2 max-w-[80%] whitespace-pre-wrap break-words';
    b.textContent = text;
    wrap.appendChild(b);
    chatLog.appendChild(wrap);
    chatLog.scrollTop = chatLog.scrollHeight;
  }
  function addMsg_t(who, text, sources=null) {
    const wrap = document.createElement('div');
    wrap.className = who === 'you' ? 'flex justify-end' : 'flex justify-start';
    const b = document.createElement('div');
    b.className = who === 'you'
      ? 'bg-sky-600 text-white rounded px-3 py-2 max-w-[80%] whitespace-pre-wrap break-words'
      : 'bg-slate-100 text-slate-900 rounded px-3 py-2 max-w-[80%] whitespace-pre-wrap break-words';
    b.textContent = text;
    wrap.appendChild(b);
    chatLog.appendChild(wrap);
    chatLog.scrollTop = chatLog.scrollHeight;

    console.log("sources : " + sources)

    if (sources && Array.isArray(sources) && sources.length > 0){
      console.log("    if (sources && Array.isArray(sources) && sources.length > 0){} - TRUE")
      const wrap_s = document.createElement('div');
      wrap_s.className = 'flex justify-start ';
      const s = document.createElement('div');
      // s.className = 'bg-slate-100 text-slate-500 text-xs rounded px-3 py-2 max-w-[80%]';
      s.className = 'text-slate-500 text-xs rounded px-2 py-1 max-w-[80%] whitespace-pre-wrap break-words';
      s.textContent = "Джерела: \n";
      s.textContent += sources.join("; ");
      wrap_s.appendChild(s)
      chatLog.appendChild(wrap_s)
      chatLog.scrollTop = chatLog.scrollHeight;
    }

  }

  chatForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const msg = chatInput.value.trim();
    if (!msg) return;
    addMsg('you', msg);
    chatInput.value = '';
    addMsg('bot', '…');

    try {
      const res = await fetch('/api/chat', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({message: msg})
      });
      const data = await res.json();
      chatLog.lastChild.remove(); // remove placeholder
      addMsg_t('bot', data.answer, data.sources || '[no answer]');
      // addMsg('bot', data.sources || '[no answer]');
      // addMsg('bot', data.answer || '[no answer]');
    } catch (err) {
      chatLog.lastChild.remove();
      addMsg('bot', 'Помилка запиту');
    }
  });

  // Upload + progress (SSE)
const uploadForm = document.getElementById('upload-form');
const fileInput = document.getElementById('file-input');
const startBtn = document.getElementById('upload-start');
const progressBox = document.getElementById('progress');
const fileNameEl = document.getElementById('file-name');
const statusLine = document.getElementById('status-line');
const bar = document.getElementById('bar');
const dl = document.getElementById('download-link');
const lastBrief = document.getElementById('last-brief');
const uploadingBanner = document.getElementById('uploading-banner');
const uploadingText = document.getElementById('uploading-text');

  // ---- Persist in-flight task across reloads ----
  const LS_KEY_TASK = 'crag_last_task';
  const LS_KEY_FILE = 'crag_last_file';

  function saveLastTask(taskId, fileName) {
    try {
      localStorage.setItem(LS_KEY_TASK, taskId);
      if (fileName) localStorage.setItem(LS_KEY_FILE, fileName);
    } catch (_) {}
  }
  function clearLastTask(taskId) {
    try {
      const cur = localStorage.getItem(LS_KEY_TASK);
      if (!taskId || cur === taskId) {
        localStorage.removeItem(LS_KEY_TASK);
        localStorage.removeItem(LS_KEY_FILE);
      }
    } catch (_) {}
  }
  function getLastTask() {
    try {
      const id = localStorage.getItem(LS_KEY_TASK);
      const fn = localStorage.getItem(LS_KEY_FILE) || '';
      return id ? { id, fileName: fn } : null;
    } catch (_) { return null; }
  }

function attachProgressSSE(taskId, fileNameFallback, onOpenCb) {
  progressBox.classList.remove('hidden');
  fileNameEl.textContent = fileNameFallback ? ('Файл: ' + fileNameFallback) : '';
  dl.classList.add('hidden');
  lastBrief.textContent = '';
  bar.style.width = '0%';
  statusLine.textContent = 'Відновлюю прогрес…';

  const ev = new EventSource('/api/progress/' + taskId);
  let opened = false;
  ev.onopen = () => {
    opened = true;
    if (uploadingText) uploadingText.textContent = 'Підключено. Очікування оновлень…';
    try { if (typeof onOpenCb === 'function') onOpenCb(); } catch (_) {}
  };
  ev.onmessage = (m) => {
    if (!opened) { opened = true; try { if (typeof onOpenCb === 'function') onOpenCb(); } catch (_) {} }
    const data = JSON.parse(m.data);
      if (!data) return;

      if (data.filename_in) {
        fileNameEl.textContent = 'Файл: ' + data.filename_in;
        saveLastTask(taskId, data.filename_in);
      }

      const total = data.total || 0;
      const done = data.done || 0;
      const pct = total ? Math.floor((done / total) * 100) : 0;
      bar.style.width = pct + '%';
      statusLine.textContent = total ? `Опрацьовано: ${done} з ${total} (${pct}%)` : 'Підготовка…';

      if (data.last_brief) {
        lastBrief.textContent = `Останній результат: ${data.last_brief}`;
      }

      if (data.status === 'done') {
        ev.close();
        dl.href = '/api/download/' + data.task_id;
        dl.classList.remove('hidden');
        statusLine.textContent = 'Готово. Можете завантажити результат.';
        // Clear the last short message once finished
        lastBrief.textContent = '';
        clearLastTask(taskId);
      } else if (data.status === 'error') {
        ev.close();
        statusLine.textContent = 'Помилка обробки';
        lastBrief.textContent = '';
        clearLastTask(taskId);
      }
    };
    ev.onerror = () => {
      // EventSource auto-reconnects; show a transient reconnecting state
      if (uploadingText) uploadingText.textContent = 'Втрачено зв\'язок. Відновлюю…';
      statusLine.textContent = 'Втрачено зв\'язок. Відновлюю…';
    };
  }

  // Reattach on reload if a task is in-flight
  window.addEventListener('load', () => {
    const last = getLastTask();
    if (last && last.id) {
      attachProgressSSE(last.id, last.fileName || '');
    }
  });

  // --- Dropzone wiring ---
  const dropzone = document.getElementById('dropzone');
  const pickBtn = document.getElementById('pick-file');
  const chosenFile = document.getElementById('chosen-file');
  const dzLabel = dropzone.querySelector('.dz-label');

  function clearDZVisual() {
    dropzone.classList.remove('ring-2','ring-sky-400','bg-sky-50');
    dropzone.classList.remove('ring-red-400');
  }
  function setChosen(file) {
    chosenFile.textContent = file ? file.name : '';
    if (file) dzLabel.textContent = `Обрано файл: ${file.name}`; else dzLabel.textContent = 'Перетягніть .docx сюди або натисніть, щоб обрати';
  }

  // Click to open picker
  dropzone.addEventListener('click', () => fileInput.click());
  pickBtn.addEventListener('click', () => fileInput.click());

  // Reflect manual selection
  fileInput.addEventListener('change', () => {
    const f = fileInput.files && fileInput.files[0];
    setChosen(f || null);
  });

  // Drag & drop handlers
  ['dragenter','dragover'].forEach(evt => dropzone.addEventListener(evt, (e) => {
    e.preventDefault(); e.stopPropagation();
    dropzone.classList.add('ring-2','ring-sky-400','bg-sky-50');
  }));
  ;['dragleave','dragend'].forEach(evt => dropzone.addEventListener(evt, (e) => {
    e.preventDefault(); e.stopPropagation();
    clearDZVisual();
  }));
  dropzone.addEventListener('drop', (e) => {
    e.preventDefault(); e.stopPropagation();
    clearDZVisual();
    const files = e.dataTransfer?.files;
    if (!files || !files.length) return;
    const f = files[0];
    if (!f.name.toLowerCase().endsWith('.docx')) {
      dropzone.classList.add('ring-2','ring-red-400');
      dzLabel.textContent = 'Потрібен файл .docx';
      setTimeout(() => { clearDZVisual(); dzLabel.textContent = 'Перетягніть .docx сюди або натисніть, щоб обрати'; }, 1600);
      return;
    }
    // Set the File on the hidden input so existing submit logic works
    const dt = new DataTransfer();
    dt.items.add(f);
    fileInput.files = dt.files;
    setChosen(f);
    // Do NOT auto-start; require explicit click on the Start button
  });

let isSubmitting = false;
uploadForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  if (isSubmitting) return;
  if (!fileInput.files.length) return;
  isSubmitting = true;
  startBtn?.setAttribute('disabled', 'disabled');
  if (uploadingText) uploadingText.textContent = 'Завантаження файлу…';
  uploadingBanner?.classList.remove('hidden');
  const fd = new FormData();
  fd.append('file', fileInput.files[0]);

  let j = null;
  try {
    const r = await fetch('/api/upload', { method: 'POST', body: fd });
    j = await r.json();
  } catch (err) {
    alert('Upload failed');
    isSubmitting = false;
    startBtn?.removeAttribute('disabled');
    uploadingBanner?.classList.add('hidden');
    return;
  }
  if (!j || !j.task_id) { alert('Upload failed'); isSubmitting = false; startBtn?.removeAttribute('disabled'); uploadingBanner?.classList.add('hidden'); return; }

    // persist & (re)attach to progress stream
    saveLastTask(j.task_id, fileInput.files[0].name);
  if (uploadingText) uploadingText.textContent = 'Підключення до прогресу…';
  attachProgressSSE(j.task_id, fileInput.files[0].name, () => {
    uploadingBanner?.classList.add('hidden');
    startBtn?.removeAttribute('disabled');
    isSubmitting = false;
  });
  return; // prevent any duplicate SSE setup below
});

  // ----- Results tab logic -----
  const resultsTBody = document.getElementById('results-tbody');
  const refreshBtn = document.getElementById('refresh-results');
  const pageSizeSel = document.getElementById('results-page-size');
  const pageInfo = document.getElementById('results-page-info');
  const btnPrev = document.getElementById('results-prev');
  const btnNext = document.getElementById('results-next');

  let resultsPage = 1;
  let resultsTotalPages = 1;
  
  function fmtSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    const kb = bytes / 1024;
    if (kb < 1024) return kb.toFixed(1) + ' KB';
    const mb = kb / 1024;
    return mb.toFixed(2) + ' MB';
  }
  function fmtDate(ts) {
    try {
      const d = new Date(ts * 1000);
      return d.toLocaleString("en-GB");
    } catch { return ''; }
  }
  async function loadResults() {
    try {
      const ps = parseInt(pageSizeSel.value || '50', 10);
      const res = await fetch(`/api/results?page=${resultsPage}&page_size=${ps}`);
      const j = await res.json();
      const rows = (j.results || []);
      resultsTBody.innerHTML = '';
      if (!rows.length) {
        resultsTBody.innerHTML = '<tr><td class="py-2 text-slate-500" colspan="4">No files yet.</td></tr>';
        resultsTotalPages = 1;
        pageInfo.textContent = `Page ${resultsPage}/1`;
        btnPrev.disabled = resultsPage <= 1;
        btnNext.disabled = resultsPage >= resultsTotalPages;
        return;
      }
      // Update pagination UI
      resultsTotalPages = j.total_pages || 1;
      pageInfo.textContent = `Page ${j.page || resultsPage}/${resultsTotalPages}`;
      btnPrev.disabled = (j.page || resultsPage) <= 1;
      btnNext.disabled = (j.page || resultsPage) >= resultsTotalPages;
      for (const r of rows) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="py-2 pr-4">${r.name}</td>
          <td class="py-2 pr-4">${fmtSize(r.size)}</td>
          <td class="py-2 pr-4">${fmtDate(r.mtime)}</td>
          <td class="py-2 pr-4">
            <a href="${r.href}" class="bg-emerald-600 text-white px-3 py-1.5 rounded hover:bg-emerald-700">Download</a>
          </td>
        `;
        resultsTBody.appendChild(tr);
      }
    } catch (e) {
      resultsTBody.innerHTML = '<tr><td class="py-2 text-red-600" colspan="4">Failed to load results</td></tr>';
    }
  }
  refreshBtn?.addEventListener('click', () => loadResults());
  pageSizeSel?.addEventListener('change', () => { resultsPage = 1; loadResults(); });
  btnPrev?.addEventListener('click', () => { if (resultsPage > 1) { resultsPage -= 1; loadResults(); }});
  btnNext?.addEventListener('click', () => { if (resultsPage < resultsTotalPages) { resultsPage += 1; loadResults(); }});

  // Initial load
  loadResults();
  // Optionally, auto-refresh every 30s while the tab is visible:
  let resultsTimer = null;
  document.addEventListener('visibilitychange', () => {
    const visible = !document.hidden && !document.getElementById('tab-results').classList.contains('hidden');
    if (visible && !resultsTimer) {
      resultsTimer = setInterval(loadResults, 30000);
    } else if (!visible && resultsTimer) {
      clearInterval(resultsTimer); resultsTimer = null;
    }
  });

  // ----- Corpus tab logic -----
  const corpusTree = document.getElementById('corpus-tree');
  const corpusRefresh = document.getElementById('corpus-refresh');
  const corpusPick = document.getElementById('corpus-pick');
  const corpusFile = document.getElementById('corpus-file');
  const corpusRelDir = document.getElementById('corpus-rel-dir');
  const corpusChosen = document.getElementById('corpus-chosen');
  const corpusSelected = document.getElementById('corpus-selected');
  const mkdirName = document.getElementById('mkdir-name');
  const mkdirBtn = document.getElementById('mkdir-btn');
  const rmdirBtn = document.getElementById('rmdir-btn');
  const collapseAllBtn = document.getElementById('collapse-all');
  const selectRootBtn = document.getElementById('select-root');
  const syncBtn = document.getElementById('sync-vs');
  const verifyBtn = document.getElementById('verify-vs');
  const initDbBtn = document.getElementById('initdb-vs');
  const dryrunBtn = document.getElementById('dryrun-vs');
  const pruneBtn = document.getElementById('prune-vs');
  const corpusReport = document.getElementById('corpus-report');
  // per-card collapses (no forced fixed positioning)
  function initCollapse(bodyId, btnId, lsKey) {
    const body = document.getElementById(bodyId);
    const btn = document.getElementById(btnId);

    if (!body || !btn) return;
    
    function setCollapsed(collapsed) {
      if (collapsed) { body.classList.add('hidden'); btn.textContent = 'Розгорнути'; }
      else { body.classList.remove('hidden'); btn.textContent = 'Згорнути'; }
    }
    try { const v = localStorage.getItem(lsKey); setCollapsed(v === '1'); } catch (_) {}
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      const collapsed = body.classList.contains('hidden');
      setCollapsed(!collapsed);
      try { localStorage.setItem(lsKey, (!collapsed) ? '1' : '0'); } catch (_) {}
    });
  }
  initCollapse('upload-body','toggle-upload','crag_collapse_upload');
  initCollapse('folders-body','toggle-folders','crag_collapse_folders');
  initCollapse('settings-body','toggle-settings','crag_collapse_settings');
  initCollapse('vs-body','toggle-vs','crag_collapse_vs');

  // Sticky headers: stack so multiple stick without overlapping
  (function initStickyStacking() {
    const container = document.getElementById('tab-corpus');
    if (!container) return;
    const headers = Array.from(container.querySelectorAll('.cs-sticky'));
    if (!headers.length) return;

    const BASE_TOP = 80; // Keep in sync with CSS
    function recompute() {
      let acc = 0;
      // Highest z-index for the earliest card when pinned
      const zTop = 100;
      for (let i = 0; i < headers.length; i++) {
        const h = headers[i];
        const card = h.closest('#upload-card, #folders-card, #settings-card, #vs-card') || h.parentElement;
        const threshold = BASE_TOP + acc;
        h.style.top = threshold + 'px';

        const rect = (card || h).getBoundingClientRect();
        const isPinned = rect.top <= threshold;
        if (isPinned) {
          acc += h.offsetHeight || 0;
          h.style.zIndex = String(zTop - i);
        } else {
          h.style.zIndex = '40';
        }
      }
    }

    // Run once and on scroll/resize
    recompute();
    window.addEventListener('scroll', recompute, { passive: true });
    window.addEventListener('resize', recompute);
    // Recompute after collapse toggles
    ['toggle-upload','toggle-folders','toggle-settings','toggle-vs'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('click', () => setTimeout(recompute, 0));
    });
    // Recompute when switching to corpus tab
    const corpusTabBtn = Array.from(document.querySelectorAll('#tabs [data-tab="corpus"]'))[0];
    if (corpusTabBtn) corpusTabBtn.addEventListener('click', () => setTimeout(recompute, 0));
  })();

  // Full-card sticky behavior: cards stick at page top after passing it, with stacking and usable scrolling
  (function initCardSticky() {
    const BASE_TOP = 0; // distance from viewport top for pinned card
    const PIN_GAP = 8;  // small gap between pinned card and the next card as it pushes
    const cards = [
      {
        el: document.getElementById('upload-card'),
        body: document.getElementById('upload-body'),
        header: document.querySelector('#upload-card .cs-card-header')
      },
      {
        el: document.getElementById('folders-card'),
        body: document.getElementById('folders-body'),
        header: document.querySelector('#folders-card .cs-card-header')
      },
      {
        el: document.getElementById('settings-card'),
        body: document.getElementById('settings-body'),
        header: document.querySelector('#settings-card .cs-card-header')
      },
      {
        el: document.getElementById('vs-card'),
        body: document.getElementById('vs-body'),
        header: document.querySelector('#vs-card .cs-card-header')
      }
    ].filter(c => c.el);

    if (!cards.length) return;

    function ensureSpacer(card) {
      if (!card.spacer) {
        const r = card.el.getBoundingClientRect();
        const spacer = document.createElement('div');
        spacer.style.height = r.height + 'px';
        spacer.style.width = '100%';
        // Preserve vertical rhythm if card had margins (most likely 0 due to flex gap)
        spacer.style.margin = getComputedStyle(card.el).margin;
        card.el.insertAdjacentElement('afterend', spacer);
        card.spacer = spacer;
      }
    }
    function removeSpacer(card) {
      if (card.spacer) { card.spacer.remove(); card.spacer = null; }
    }

    function pinCard(card, top, z) {
      ensureSpacer(card);
      const anchor = card.spacer || card.el;
      const rect = anchor.getBoundingClientRect();
      card.el.style.position = 'fixed';
      card.el.style.top = top + 'px';
      card.el.style.left = (rect.left + window.scrollX) + 'px';
      card.el.style.width = rect.width + 'px';
      card.el.style.zIndex = String(z);
      card.el.style.margin = '0';
      card.el.style.transform = 'translateY(0)';
      card.el.classList.add('cs-shadow');
      // Make the body scrollable within the viewport area
      if (card.body) {
        const headerH = card.header ? card.header.offsetHeight : 0;
        const avail = Math.max(120, window.innerHeight - top - 12);
        card.body.style.maxHeight = Math.max(80, avail - headerH) + 'px';
        card.body.style.overflowY = 'auto';
      }
      card.pinned = true;
    }
    function unpinCard(card) {
      card.el.style.position = '';
      card.el.style.top = '';
      card.el.style.left = '';
      card.el.style.width = '';
      card.el.style.zIndex = '';
      card.el.classList.remove('cs-shadow');
      if (card.body) {
        card.body.style.maxHeight = '';
        card.body.style.overflowY = '';
      }
      card.el.style.margin = '';
      card.el.style.transform = '';
      removeSpacer(card);
      card.pinned = false;
    }

    function recompute() {
      // Only expanded cards can stick
      const expanded = cards.filter(c => c.body && !c.body.classList.contains('hidden'));

      // Unpin collapsed cards immediately
      for (const c of cards) {
        if (!expanded.includes(c)) unpinCard(c);
      }

      // Stack multiple expanded cards after passing the top threshold
      let stackTop = BASE_TOP;
      let zTop = 300; // ensure pinned cards are above other content
      const pinnedNow = new Set();

      for (const c of expanded) {
        const anchorTop = (c.spacer ? c.spacer.getBoundingClientRect().top : c.el.getBoundingClientRect().top);
        if (anchorTop <= stackTop) {
          // Pin at current stack position
          pinCard(c, stackTop, zTop);
          pinnedNow.add(c);
          // Keep spacer in sync with actual pinned height
          const h = c.el.getBoundingClientRect().height;
          if (c.spacer) c.spacer.style.height = h + 'px';
          // Advance stack for next expanded card
          stackTop += h + PIN_GAP;
          zTop -= 1;
        } else {
          // Not yet at the stack threshold – ensure it's not pinned
          unpinCard(c);
        }
      }

      // Unpin any expanded card that is not in the pinned set
      for (const c of expanded) {
        if (!pinnedNow.has(c)) unpinCard(c);
      }
    }

    // Wire events
    recompute();
    window.addEventListener('scroll', recompute, { passive: true });
    window.addEventListener('resize', recompute);
    ;['toggle-upload','toggle-folders','toggle-settings','toggle-vs'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('click', () => setTimeout(recompute, 0));
    });
    const corpusBtn = Array.from(document.querySelectorAll('#tabs [data-tab="corpus"]'))[0];
    if (corpusBtn) corpusBtn.addEventListener('click', () => setTimeout(recompute, 0));
  })();
  const sourceLabelSel = document.getElementById('source-label-mode');

  let collapsed = new Set();
  let selectedDir = '';

  corpusPick?.addEventListener('click', () => corpusFile.click());
  corpusFile?.addEventListener('change', () => {
    const f = corpusFile.files && corpusFile.files[0];
    corpusChosen.textContent = f ? f.name : '';
  });

  function ensureSelected(dir) {
    selectedDir = dir;
    corpusRelDir.value = dir;
    corpusSelected.textContent = dir ? dir : '/';
    // Persist selected directory for future reloads
    try { localStorage.setItem(LS_SELECTED_KEY, dir); } catch {}
    // Highlight selected folder label elements
    corpusTree.querySelectorAll('[data-folder]').forEach(el => {
      const p = el.getAttribute('data-folder') || '';
      if (p === dir) el.classList.add('bg-sky-50'); else el.classList.remove('bg-sky-50');
    });
  }

  function buildTree(rows) {
    const root = {};
    for (const r of rows) {
      const parts = r.relpath.split('/');
      let node = root;
      const isDir = (r.kind === 'dir');
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const isLast = i === parts.length - 1;
        if (isLast) {
          if (isDir) {
            // ensure this directory node exists
            node[part] = node[part] || {};
          } else {
            node['$files'] = node['$files'] || [];
            node['$files'].push({ name: part, info: r, path: parts.slice(0, i).join('/') });
          }
        } else {
          node[part] = node[part] || {};
          node = node[part];
        }
      }
    }
    return root;
  }

  function countFiles(node) {
    let c = 0;
    if (node['$files']) c += node['$files'].length;
    for (const k of Object.keys(node)) {
      if (k === '$files') continue;
      c += countFiles(node[k]);
    }
    return c;
  }

  function renderTree(node, basePath='') {
    const ul = document.createElement('ul');
    ul.className = 'pl-4 list-disc';
    const folders = Object.keys(node).filter(k => k !== '$files').sort();
    for (const name of folders) {
      const path = basePath ? `${basePath}/${name}` : name;
      const li = document.createElement('li');
      li.innerHTML = `<div class="cursor-pointer px-1 rounded hover:bg-slate-50 font-medium text-slate-700" data-folder="${path}">${name}/</div>`;
      const child = renderTree(node[name], path);
      li.appendChild(child);
      ul.appendChild(li);
    }
    // files in this level
    if (node['$files']) {
      for (const f of node['$files'].sort((a,b)=>a.name.localeCompare(b.name))) {
        const li = document.createElement('li');
        li.textContent = f.name;
        const btn = document.createElement('button');
        btn.textContent = 'Видалити';
        // Slightly softer red and a bit more left margin for clearer spacing
        btn.className = 'ml-3 text-xs border border-red-200 text-red-600 px-2 py-0.5 rounded hover:bg-red-100';
        btn.setAttribute('data-rel', f.info.relpath);
        btn.addEventListener('click', async () => {
          const rel = btn.getAttribute('data-rel');
          if (!confirm(`Видалити ${rel}?`)) return;
          try {
            const r = await fetch('/api/corpus/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ relpath: rel }) });
            const j = await r.json();
            if (!j.deleted) alert('Не вдалося видалити'); else loadCorpus();
          } catch { alert('Помилка видалення'); }
        });
        li.appendChild(btn);
        ul.appendChild(li);
      }
    }
    return ul;
  }

  // Minimal, indented tree with native triangles via <details>/<summary>
  // Persist open folders and selected folder in localStorage
  const LS_OPEN_KEY = 'crag_corpus_open_set';
  const LS_SELECTED_KEY = 'crag_corpus_selected_dir';

  function loadOpenSet() {
    try {
      const raw = localStorage.getItem(LS_OPEN_KEY);
      if (!raw) return new Set();
      const arr = JSON.parse(raw);
      return new Set(Array.isArray(arr) ? arr : []);
    } catch { return new Set(); }
  }
  function saveOpenSet(set) {
    try { localStorage.setItem(LS_OPEN_KEY, JSON.stringify(Array.from(set))); } catch {}
  }
  function isOpenPath(openSet, path) {
    return openSet.has(path || '');
  }
  function setPathOpen(openSet, path, open) {
    if (!path && path !== '') return openSet;
    if (open) openSet.add(path); else openSet.delete(path);
    saveOpenSet(openSet);
    return openSet;
  }

  function renderTree2(node, basePath='', level=0, openSet = loadOpenSet()) {
    const container = document.createElement('div');
    const folders = Object.keys(node).filter(k => k !== '$files').sort();
    for (const name of folders) {
      const path = basePath ? `${basePath}/${name}` : name;
      const details = document.createElement('details');
      // Restore persisted open state for this folder
      if (isOpenPath(openSet, path)) details.setAttribute('open', '');
      const summary = document.createElement('summary');
      summary.setAttribute('data-folder', path);
      summary.className = 'cursor-pointer font-medium text-slate-700';
      summary.style.paddingLeft = `${level * 16}px`;
      summary.textContent = `${name}/`;
      details.appendChild(summary);
      const child = renderTree2(node[name], path, level + 1, openSet);
      details.appendChild(child);
      // Persist open/closed on toggle
      details.addEventListener('toggle', () => {
        const nowOpen = details.open;
        const os = loadOpenSet();
        setPathOpen(os, path, nowOpen);
      });
      container.appendChild(details);
    }
    if (node['$files']) {
      for (const f of node['$files'].sort((a,b)=>a.name.localeCompare(b.name))) {
        const row = document.createElement('div');
        row.style.paddingLeft = `${level * 16 + 16}px`;
        const label = document.createElement('span');
        label.textContent = f.name;
        label.className = 'text-slate-700';
        const btn = document.createElement('button');
        btn.textContent = 'Видалити';
        btn.className = 'ml-2 text-xs border border-red-300 text-red-700 px-1.5 py-0.5 rounded hover:bg-red-50';
        btn.setAttribute('data-rel', f.info.relpath);
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const rel = btn.getAttribute('data-rel');
          if (!confirm(`Видалити ${rel}?`)) return;
          try {
            const r = await fetch('/api/corpus/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ relpath: rel }) });
            const j = await r.json();
            if (!j.deleted) alert('Не вдалося видалити'); else loadCorpus();
          } catch { alert('Помилка видалення'); }
        });
        row.appendChild(label);
        row.appendChild(btn);
        container.appendChild(row);
      }
    }
    return container;
  }

  async function loadCorpus() {
    try {
      const res = await fetch(`/api/corpus/list?page=1&page_size=100000`);
      const j = await res.json();
      const rows = j.results || [];
      const tree = buildTree(rows);
      corpusTree.innerHTML = '';
      const dom = renderTree2(tree, '', 0, loadOpenSet());
      corpusTree.appendChild(dom);
      // wire events
      corpusTree.querySelectorAll('button.toggle').forEach(btn => {
        btn.addEventListener('click', () => {
          const p = btn.getAttribute('data-path');
          if (collapsed.has(p)) collapsed.delete(p); else collapsed.add(p);
          loadCorpus();
        });
      });
      corpusTree.querySelectorAll('.set-dest').forEach(btn => {
        btn.addEventListener('click', () => {
          const p = btn.getAttribute('data-folder') || '';
          ensureSelected(p);
        });
      });
      corpusTree.querySelectorAll('[data-folder]').forEach(div => {
        div.addEventListener('click', (e) => {
          // avoid double-handling when clicking nested button
          const t = e.target;
          if (t && t.classList && t.classList.contains('set-dest')) return;
          const p = div.getAttribute('data-folder') || '';
          ensureSelected(p);
        });
      });
      corpusTree.querySelectorAll('.btn-del').forEach(btn => {
        btn.addEventListener('click', async () => {
          const rel = btn.getAttribute('data-rel');
          if (!confirm(`Видалити ${rel}?`)) return;
          try {
            const r = await fetch('/api/corpus/delete', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ relpath: rel }) });
            const j = await r.json();
            if (!j.deleted) alert('Не вдалося видалити'); else loadCorpus();
          } catch { alert('Помилка видалення'); }
        });
      });
      // default select last selected dir if available, else root
      try {
        const prevSel = localStorage.getItem(LS_SELECTED_KEY);
        if (selectedDir === '' && prevSel !== null) ensureSelected(prevSel);
      } catch (_) {}
      if (selectedDir === '') ensureSelected('');

      // Update collapse-all button label based on current state
      const anyOpen = !!corpusTree.querySelector('details[open]');
      if (collapseAllBtn) collapseAllBtn.textContent = anyOpen ? 'Згорнути все' : 'Розгорнути все';
    } catch (e) {
      corpusTree.innerHTML = '<div class="text-red-600">Не вдалося завантажити список</div>';
    }
  }

  corpusRefresh?.addEventListener('click', () => loadCorpus());

  collapseAllBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    // Toggle: if any folder is open -> collapse all; else expand all
    const details = Array.from(corpusTree.querySelectorAll('details'));
    const anyOpen = details.some(d => d.open);
    if (anyOpen) {
      details.forEach(d => { d.open = false; });
      try { localStorage.removeItem(LS_OPEN_KEY); } catch {}
      if (collapseAllBtn) collapseAllBtn.textContent = 'Розгорнути все';
    } else {
      details.forEach(d => { d.open = true; });
      // Persist: collect all folder paths
      const set = new Set();
      corpusTree.querySelectorAll('summary[data-folder]').forEach(s => {
        const p = s.getAttribute('data-folder') || '';
        set.add(p);
      });
      saveOpenSet(set);
      if (collapseAllBtn) collapseAllBtn.textContent = 'Згорнути все';
    }
  });

  selectRootBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    ensureSelected('');
  });

  syncBtn?.addEventListener('click', async (e) => {
    e.preventDefault();
    const prevText = syncBtn.textContent;
    syncBtn.textContent = 'Синхронізація…';
    syncBtn.setAttribute('disabled', 'disabled');
    try {
      const r = await fetch('/api/corpus/sync', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'apply' }) });
      const j = await r.json();
      if (!j.ok) alert('Синхронізація не вдалася: ' + (j.error || '')); else alert('Синхронізація завершена');
      if (corpusReport) corpusReport.textContent = JSON.stringify(j, null, 2);
      loadCorpus();
    } catch (err) {
      alert('Синхронізація не вдалася');
    } finally {
      syncBtn.removeAttribute('disabled');
      syncBtn.textContent = prevText;
    }
  });

  verifyBtn?.addEventListener('click', async (e) => {
    e.preventDefault();
    const prev = verifyBtn.textContent;
    verifyBtn.textContent = 'Перевіряю…';
    verifyBtn.setAttribute('disabled', 'disabled');
    try {
      const r = await fetch('/api/corpus/verify');
      const j = await r.json();
      if (corpusReport) corpusReport.textContent = JSON.stringify(j, null, 2);
    } catch (e) { alert('Помилка перевірки'); }
    finally { verifyBtn.textContent = prev; verifyBtn.removeAttribute('disabled'); }
  });

  dryrunBtn?.addEventListener('click', async (e) => {
    e.preventDefault();
    const prev = dryrunBtn.textContent;
    dryrunBtn.textContent = 'Dry‑run…';
    dryrunBtn.setAttribute('disabled', 'disabled');
    try {
      const r = await fetch('/api/corpus/sync', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ mode: 'dry' })});
      const j = await r.json();
      if (corpusReport) corpusReport.textContent = JSON.stringify(j, null, 2);
    } catch (e) { alert('Помилка dry‑run'); }
    finally { dryrunBtn.textContent = prev; dryrunBtn.removeAttribute('disabled'); }
  });

  initDbBtn?.addEventListener('click', async (e) => {
    e.preventDefault();
    const prev = initDbBtn.textContent;
    initDbBtn.textContent = 'Ініціалізація…';
    initDbBtn.setAttribute('disabled', 'disabled');
    try {
      const r = await fetch('/api/corpus/sync', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mode: 'init_db' })
      });
      const j = await r.json();
      if (!j.ok) alert('Init from DB не вдалося: ' + (j.error || ''));
      if (corpusReport) corpusReport.textContent = JSON.stringify(j, null, 2);
    } catch (e) { alert('Помилка init from DB'); }
    finally { initDbBtn.textContent = prev; initDbBtn.removeAttribute('disabled'); }
  });

  pruneBtn?.addEventListener('click', async (e) => {
    e.preventDefault();
    const prev = pruneBtn.textContent;
    pruneBtn.textContent = 'Очищення…';
    pruneBtn.setAttribute('disabled', 'disabled');
    try {
      const r = await fetch('/api/corpus/prune', { method: 'POST' });
      const j = await r.json();
      if (!j.ok) alert('Очищення не вдалося: ' + (j.error || ''));
      if (corpusReport) corpusReport.textContent = JSON.stringify(j, null, 2);
    } catch (e) { alert('Помилка очищення'); }
    finally { pruneBtn.textContent = prev; pruneBtn.removeAttribute('disabled'); }
  });

  // Controls collapse/expand with localStorage persistence
  (function initControlsCollapse() {
    // Gracefully handle absence of toggle controls in markup
    const controlsGrid = document.getElementById('controls-row');
    const toggleControls = document.getElementById('toggle-controls');
    const LS_KEY = 'crag_controls_collapsed';
    function setCollapsed(collapsed) {
      if (!controlsGrid || !toggleControls) return;
      if (collapsed) {
        controlsGrid.classList.add('hidden');
        toggleControls.textContent = 'Розгорнути панель';
      } else {
        controlsGrid.classList.remove('hidden');
        toggleControls.textContent = 'Згорнути панель';
      }
    }
    // restore state
    try {
      const v = localStorage.getItem(LS_KEY);
      setCollapsed(v === '1');
    } catch (_) {}
    // toggle handler
    toggleControls?.addEventListener('click', (e) => {
      e.preventDefault();
      const collapsed = controlsGrid?.classList.contains('hidden');
      setCollapsed(!collapsed);
      try { localStorage.setItem(LS_KEY, (!collapsed) ? '1' : '0'); } catch (_) {}
    });
  })();

  // Initialize source label selector from server
  (async function initSourceLabel() {
    try {
      const r = await fetch('/api/source_label');
      const j = await r.json();
      if (j && j.mode && sourceLabelSel) {
        sourceLabelSel.value = j.mode;
      }
    } catch {}
  })();

  sourceLabelSel?.addEventListener('change', async () => {
    try {
      const mode = sourceLabelSel.value;
      await fetch('/api/source_label', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode }) });
      alert('Режим відображення джерела змінено. Нові запити/обробки використовуватимуть новий формат.');
    } catch {
      alert('Не вдалося змінити режим відображення джерела');
    }
  });

  mkdirBtn?.addEventListener('click', async (e) => {
    e.preventDefault();
    const name = (mkdirName.value || '').trim();
    if (!name) return;
    try {
      const r = await fetch('/api/corpus/mkdir', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ parent: selectedDir, name }) });
      const j = await r.json();
      if (!j.created) { alert('Не вдалося створити папку'); return; }
      mkdirName.value = '';
      // select newly created folder
      ensureSelected(selectedDir ? `${selectedDir}/${name}` : name);
      loadCorpus();
    } catch { alert('Помилка створення папки'); }
  });

  rmdirBtn?.addEventListener('click', async (e) => {
    e.preventDefault();
    if (!selectedDir) { alert('Оберіть папку для видалення'); return; }
    if (!confirm(`Видалити папку ${selectedDir} та всі файли?`)) return;
    try {
      const r = await fetch('/api/corpus/rmdir', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ relpath: selectedDir }) });
      const j = await r.json();
      if (!j.deleted) { alert('Не вдалося видалити папку'); return; }
      // select parent folder
      const parts = selectedDir.split('/');
      parts.pop();
      ensureSelected(parts.join('/') || '');
      loadCorpus();
    } catch { alert('Помилка видалення папки'); }
  });

  document.getElementById('corpus-upload-form')?.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!corpusFile.files || !corpusFile.files.length) return;
    const fd = new FormData();
    fd.append('file', corpusFile.files[0]);
    if (corpusRelDir.value) fd.append('rel_dir', corpusRelDir.value);
    try {
      const r = await fetch('/api/corpus/upload', { method: 'POST', body: fd });
      const j = await r.json();
      if (!j.saved) alert('Завантаження не вдалося');
      corpusFile.value = '';
      corpusChosen.textContent = '';
      loadCorpus();
    } catch { alert('Помилка завантаження'); }
  });
</script>
{% endblock %}
